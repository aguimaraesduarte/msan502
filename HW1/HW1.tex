\documentclass[]{article}
\usepackage{lmodern}
\usepackage{amssymb,amsmath}
\usepackage{ifxetex,ifluatex}
\usepackage{listings}
\usepackage{fixltx2e} % provides \textsubscript
\ifnum 0\ifxetex 1\fi\ifluatex 1\fi=0 % if pdftex
  \usepackage[T1]{fontenc}
  \usepackage[utf8]{inputenc}
\else % if luatex or xelatex
  \ifxetex
    \usepackage{mathspec}
  \else
    \usepackage{fontspec}
  \fi
  \defaultfontfeatures{Ligatures=TeX,Scale=MatchLowercase}
  \newcommand{\euro}{â‚¬}
\fi
% use upquote if available, for straight quotes in verbatim environments
\IfFileExists{upquote.sty}{\usepackage{upquote}}{}
% use microtype if available
\IfFileExists{microtype.sty}{%
\usepackage{microtype}
\UseMicrotypeSet[protrusion]{basicmath} % disable protrusion for tt fonts
}{}
\usepackage[margin=1in]{geometry}
\usepackage{hyperref}
\PassOptionsToPackage{usenames,dvipsnames}{color} % color is loaded by hyperref
\hypersetup{unicode=true,
            pdftitle={Untitled},
            pdfauthor={Andre Guimaraes Duarte},
            pdfborder={0 0 0},
            breaklinks=true}
\urlstyle{same}  % don't use monospace font for urls
\usepackage{color}
\usepackage{fancyvrb}
\newcommand{\VerbBar}{|}
\newcommand{\VERB}{\Verb[commandchars=\\\{\}]}
\DefineVerbatimEnvironment{Highlighting}{Verbatim}{commandchars=\\\{\}}
% Add ',fontsize=\small' for more characters per line
\usepackage{framed}
\definecolor{shadecolor}{RGB}{248,248,248}
\newenvironment{Shaded}{\begin{snugshade}}{\end{snugshade}}
\newcommand{\KeywordTok}[1]{\textcolor[rgb]{0.13,0.29,0.53}{\textbf{{#1}}}}
\newcommand{\DataTypeTok}[1]{\textcolor[rgb]{0.13,0.29,0.53}{{#1}}}
\newcommand{\DecValTok}[1]{\textcolor[rgb]{0.00,0.00,0.81}{{#1}}}
\newcommand{\BaseNTok}[1]{\textcolor[rgb]{0.00,0.00,0.81}{{#1}}}
\newcommand{\FloatTok}[1]{\textcolor[rgb]{0.00,0.00,0.81}{{#1}}}
\newcommand{\ConstantTok}[1]{\textcolor[rgb]{0.00,0.00,0.00}{{#1}}}
\newcommand{\CharTok}[1]{\textcolor[rgb]{0.31,0.60,0.02}{{#1}}}
\newcommand{\SpecialCharTok}[1]{\textcolor[rgb]{0.00,0.00,0.00}{{#1}}}
\newcommand{\StringTok}[1]{\textcolor[rgb]{0.31,0.60,0.02}{{#1}}}
\newcommand{\VerbatimStringTok}[1]{\textcolor[rgb]{0.31,0.60,0.02}{{#1}}}
\newcommand{\SpecialStringTok}[1]{\textcolor[rgb]{0.31,0.60,0.02}{{#1}}}
\newcommand{\ImportTok}[1]{{#1}}
\newcommand{\CommentTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textit{{#1}}}}
\newcommand{\DocumentationTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{{#1}}}}}
\newcommand{\AnnotationTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{{#1}}}}}
\newcommand{\CommentVarTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{{#1}}}}}
\newcommand{\OtherTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{{#1}}}
\newcommand{\FunctionTok}[1]{\textcolor[rgb]{0.00,0.00,0.00}{{#1}}}
\newcommand{\VariableTok}[1]{\textcolor[rgb]{0.00,0.00,0.00}{{#1}}}
\newcommand{\ControlFlowTok}[1]{\textcolor[rgb]{0.13,0.29,0.53}{\textbf{{#1}}}}
\newcommand{\OperatorTok}[1]{\textcolor[rgb]{0.81,0.36,0.00}{\textbf{{#1}}}}
\newcommand{\BuiltInTok}[1]{{#1}}
\newcommand{\ExtensionTok}[1]{{#1}}
\newcommand{\PreprocessorTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textit{{#1}}}}
\newcommand{\AttributeTok}[1]{\textcolor[rgb]{0.77,0.63,0.00}{{#1}}}
\newcommand{\RegionMarkerTok}[1]{{#1}}
\newcommand{\InformationTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{{#1}}}}}
\newcommand{\WarningTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{{#1}}}}}
\newcommand{\AlertTok}[1]{\textcolor[rgb]{0.94,0.16,0.16}{{#1}}}
\newcommand{\ErrorTok}[1]{\textcolor[rgb]{0.64,0.00,0.00}{\textbf{{#1}}}}
\newcommand{\NormalTok}[1]{{#1}}
\usepackage{graphicx,grffile}
\makeatletter
\def\maxwidth{\ifdim\Gin@nat@width>\linewidth\linewidth\else\Gin@nat@width\fi}
\def\maxheight{\ifdim\Gin@nat@height>\textheight\textheight\else\Gin@nat@height\fi}
\makeatother
% Scale images if necessary, so that they will not overflow the page
% margins by default, and it is still possible to overwrite the defaults
% using explicit options in \includegraphics[width, height, ...]{}
\setkeys{Gin}{width=\maxwidth,height=\maxheight,keepaspectratio}
\setlength{\parindent}{0pt}
\setlength{\parskip}{6pt plus 2pt minus 1pt}
\setlength{\emergencystretch}{3em}  % prevent overfull lines
\providecommand{\tightlist}{%
  \setlength{\itemsep}{0pt}\setlength{\parskip}{0pt}}
\setcounter{secnumdepth}{0}

%%% Use protect on footnotes to avoid problems with footnotes in titles
\let\rmarkdownfootnote\footnote%
\def\footnote{\protect\rmarkdownfootnote}

%%% Change title format to be more compact
\usepackage{titling}

% Create subtitle command for use in maketitle
\newcommand{\subtitle}[1]{
  \posttitle{
    \begin{center}\large#1\end{center}
    }
}

\setlength{\droptitle}{-2em}
  \title{MSAN 502 - Homework 1}
  \pretitle{\vspace{\droptitle}\centering\huge}
  \posttitle{\par}
  \author{Andre Guimaraes Duarte}
  \preauthor{\centering\large\emph}
  \postauthor{\par}
  \predate{\centering\large\emph}
  \postdate{\par}
  \date{July 20, 2016}



% Redefines (sub)paragraphs to behave more like sections
\ifx\paragraph\undefined\else
\let\oldparagraph\paragraph
\renewcommand{\paragraph}[1]{\oldparagraph{#1}\mbox{}}
\fi
\ifx\subparagraph\undefined\else
\let\oldsubparagraph\subparagraph
\renewcommand{\subparagraph}[1]{\oldsubparagraph{#1}\mbox{}}
\fi

\begin{document}
\maketitle

\section*{Problem 1}
The python file corresponding to this part of the homework is \texttt{HW1\_1.py}.

\subsection*{A}
We have:

\[
A= \left[ \begin{array}{cccccccccc}
  1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 & 9 & 10\\
  11 & 12 & 13 & 14 & 15 & 16 & 17 & 18 & 19 & 20\\
  21 & 22 & 23 & 24 & 25 & 26 & 27 & 28 & 29 & 30\\
  31 & 32 & 33 & 34 & 35 & 36 & 37 & 38 & 39 & 40\\
  41 & 24 & 43 & 44 & 45 & 46 & 47 & 48 & 49 & 50\\
  51 & 52 & 53 & 54 & 55 & 56 & 57 & 58 & 59 & 60\\
  61 & 62 & 63 & 64 & 65 & 66 & 67 & 68 & 69 & 70\\
  71 & 72 & 73 & 74 & 75 & 76 & 77 & 78 & 79 & 80\\
  81 & 82 & 83 & 84 & 85 & 86 & 87 & 88 & 89 & 90\\
  91 & 92 & 93 & 94 & 95 & 96 & 97 & 98 & 99 & 100
\end{array} \right]
%
\text{, }v= \left[ \begin{array}{c}
  1\\
  2\\
  3\\
  4\\
  5\\
  6\\
  7\\
  8\\
  9\\
  10
\end{array} \right]
%
\text{, and }b= \left[ \begin{array}{c}
  1\\
  1\\
  1\\
  1\\
  1\\
  1\\
  1\\
  1\\
  1\\
  1
\end{array} \right]
\]

We use \texttt{linalg.solve} from the package \texttt{numpy} in order to solve $Ax = b$ and $Ax = v$. The solutions given by this function are:

\[
Ax = b \Leftrightarrow x = \left[ \begin{array}{c}
  -0.08789062\\
  -0.09179688\\
  0.03125\\
  -0.02734375\\
  0.08203125\\
  -0.0234375\\
  0.05273438\\
  0.00195312\\
  -0.0078125\\
  0.0703125
\end{array} \right]
%
\text{, and }
%
Ax = v \Leftrightarrow x = \left[ \begin{array}{c}
  -0.003125\\
  0.00546875\\
  -0.05664062\\
  -0.02734375\\
  0.16601562\\
  -0.07226562\\
  -0.01171875\\
  0.00390625\\
  0.03125\\
  0.06445312
\end{array} \right]
\]

We can easily verify that these solutions, \texttt{x1} and \texttt{x2} in my python file, are indeed correct by using the following code:

\begin{lstlisting}[language=Python]
Ax1 = np.dot(A, x1) # == b
Ax2 = np.dot(A, x2) # == v
\end{lstlisting}

Indeed, we get that $Ax1 = b$ and $Ax2 = v$. I used the \texttt{numpy} function \texttt{isclose()} instead of the simple equivalence comparison (\texttt{==}) because of floating point approximations. We do get the desired result though.

\subsection*{B}
The above matrix $A$ is singular, meaning that, by using the elimination method to solve the system, we would have hit a failure at some point of the algorithm (actually fairly early, after the second row operation in fact). But \texttt{linalg.solve} is \"smart\" enough to overcome this problem.

In order to solve this problem ourselves, one solution is to create a second 10x10 matrix $R(\epsilon)$ whose entries are indepentent and identically distributed random variables $X_{i,j} \sim U(-\epsilon, \epsilon)$ that we add to our original matrix $A$. We then solve the problem by using the new matrix $A + R(\epsilon)$.

In python, I created a function \texttt{randomMatrix(e)} that generates a 10x10 matrix as described above, where $\epsilon$ is set by the user. It is then easy to create different matrices according to the values of $\epsilon$ that we want.

\begin{lstlisting}[language=Python]
def randomMatrix(e):
  # Create matrix R (10x10) filled with zeros
  R = np.zeros(100).reshape(10, 10)
  # For every line
  for i in range(len(R)):
    # For every column
    for j in range(len(R[i])):
      # Replace R[i,j] with a random variable from a uniform(-epsilon, epsilon)
      R[i][j] = random.uniform(-e, e)

  # Return the matrix
  return R

# Create matrix R (10x10) with random noise
e = 0.01
R = randomMatrix(e)
\end{lstlisting}

Using this new matrix $A + R(\epsilon)$, for various values of $\epsilon > 0$ ranging from $0.01$ to $1$, we can compute the two earlier systems ($Ax = b$ and $Ax = v$), and we do get the same results as before.

\subsection*{C}
This noise idea to answer $Ax = b$ and $Ax = v$ is interesting. By adding even a little bit of random noise to our singular matrix, we make it non-singular, and therefore (almost certainly) solvable. By changing a little bit the values of $A$, we don't seem to change the solution $x$ by much. In fact, since A is a fairly large matrix, we can expect the overall impact of random uniform noise (centered around 0!) in \textbf{all} values of $A$ to almost cancel itself out in the solution. This is due to the fact that the uniform distribution we chose (from which we sample random variables) is centered around 0. The noise on a line tends to average around 0, meaning that the impact on the solution will be negligible.

\newpage
\section*{Problem 2}
The python files corresponding to this part of the project are \texttt{Eliminate.py} and \texttt{HW1\_2.py}.

\subsection*{A}
The python file \texttt{Eliminate.py} contains the algorithm that I implemented for elimination. I added a few checks in the beginning to make sure that the matrices are indeed matrices, that they have correct dimensions, etc \ldots My algorithm kicks out if it encounters a temporary or permanent failure. It prints an error message to explain what happened, and then exits the program.

Running my algorithm to solve the previous problems ($Ax = b$ and $Ax = v$) causes it to hit a permanent failure, leading to no or infinitely many solutions to the problems. This is because the matrix $A$, as seen previously, is singular: at one point (in the beginning of the algorithm), the third row is equal to two times the second row. After that round of row operations, the entire third row will contain only zeros. This causes the failure in the algorithm.

\subsection*{B}
I decided to create a new file for this question, in order to keep \texttt{Eliminate.py} \"clean\". The code for this question is in \texttt{HW1\_2.py}. 

It is interesting to compare the performance of my implementation of the elimination algorithm to \texttt{linalg.solve}. To do so, I created a loop that creates a matrix $R(0.5)$ and uses my algorithm and \texttt{linalg.solve} to find a solution to $(A+R(0.5))x = b$ for $n = 100\text{, } 1000\text{, } 5000\text{, and } 10000$ and measured the time taken by each algorithm, then took the mean of all 10 runs. I commented out all \texttt{print} statements as to not slow it down. The results are shown in the table \ref{times} below.
 
\begin{table}[h!]
\centering
\begin{tabular}{|c|c|c|} 
 \hline
 $n$ & Mean time taken by my algorithm (s) & Mean time taken by \texttt{linalg.solve} (s)\\ 
 \hline
 100 & $0.4493$ & $0.0026$ \\ 
 1000 & $13.3276$ & $0.1080$ \\
 5000* & $409.8180$ & $5.6591$ \\
 10000** & $2249.7651$ & $47.1378$ \\ 
 \hline
\end{tabular}
\caption{Summary of the time taken by my implementation of the elimination algorithm and \texttt{linalg.solve} to solve $Ax = b$, for 10 runs of the algorithms (*: only 5 runs; **: only 1 run).}
\label{times}
\end{table}

We can clearly see that \texttt{linalg.solve} is clearly better optimized to tackle problems of this type. While my implementation is acceptable with $n$ up to about $1000$, it seriously starts to struggle with larger data sets, whereas \texttt{linalg.solve} has no problems. It probably does not use the elimination algorithm in its full extent, but uses other methods to achieve faster results. However, it is nice to see that my implementation works, even for pretty large data sets.

\end{document}
